/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package sudoku;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.ArrayDeque;
import java.util.Deque;

import org.junit.Test;

public class SudokuTest {
    // int[][] n2MainWorkingSudoku = Backtrack.generateSudoku(2,2400);
    // int[][] n3MainWorkingSudoku = Backtrack.generateSudoku(3,2400);
    // int[][] n4MainWorkingSudoku = Backtrack.generateSudoku(4,2400);
    int[][] n2MainWorkingSudoku = Backtrack.generateSudoku(2, 2400);
    int[][] n3MainWorkingSudoku = Backtrack.generateSudoku(3, 2400);
    int[][] n4MainWorkingSudoku = Backtrack.generateSudoku(4, 2400);

    public int[][] aWorkingSudoku = new int[][] {
            { 0, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 0, 0, 0 },
            { 0, 0, 0, 0 },
    };
    public int[][] aWorkingSudoku1 = new int[][] {
            { 4, 0, 0, 0 },
            { 2, 0, 1, 0 },
            { 0, 0, 3, 0 },
            { 0, 0, 0, 0 },
    };
    public int[][] aWorkingSudoku2 = new int[][] {
            { 4, 1, 2, 3 },
            { 2, 3, 1, 4 },
            { 1, 4, 3, 2 },
            { 3, 2, 4, 1 },
    };
    public int[][] aWorkingSudoku3 = new int[][] {
            { 0, 0, 2, 0 },
            { 0, 0, 0, 4 },
            { 1, 0, 3, 0 },
            { 0, 0, 0, 0 },
    };
    public int[][] aWorkingSudoku4 = new int[][] {
            { 4, 0, 2, 0 },
            { 2, 3, 1, 4 },
            { 1, 0, 3, 0 },
            { 3, 0, 4, 0 },
    };

    public int[][] aNotWorkingSudoku1 = new int[][] {
            { 4, 0, 0, 0 },
            { 2, 0, 1, 0 },
            { 4, 0, 3, 0 },
            { 0, 0, 0, 0 },
    };
    public int[][] aNotWorkingSudoku2 = new int[][] {
            { 4, 2, 0, 0 },
            { 2, 0, 1, 0 },
            { 0, 0, 3, 0 },
            { 0, 0, 0, 0 },
    };
    public int[][] aNotWorkingSudoku3 = new int[][] {
            { 4, 0, 0, 4 },
            { 2, 0, 1, 0 },
            { 0, 0, 3, 0 },
            { 0, 0, 0, 0 },
    };

    Backtrack backTrackAlgo = new Backtrack();
    // Sudoku sudoku = new Sudoku(n2MainWorkingSudoku);

    @Test
    public void testBacktrack() {
        assertTrue(Backtrack.backtrack(n2MainWorkingSudoku, 0, 0));
        assertTrue(Backtrack.backtrack(n3MainWorkingSudoku, 0, 0));
        assertTrue(Backtrack.backtrack(n4MainWorkingSudoku, 0, 0));
        assertTrue(Backtrack.backtrack(aWorkingSudoku, 0, 0));

        assertFalse(Backtrack.backtrack(aNotWorkingSudoku1, 0, 0));
        assertFalse(Backtrack.backtrack(aNotWorkingSudoku2, 0, 0));
        assertFalse(Backtrack.backtrack(aNotWorkingSudoku3, 0, 0));

    }

    @Test
    public void testCanPlace() {
        assertTrue(Sudoku.canPlace(aWorkingSudoku, 0, 0, 4));
        assertTrue(Sudoku.canPlace(aWorkingSudoku, 0, 0, 10));
        assertTrue(Sudoku.canPlace(aWorkingSudoku1, 0, 0, 10));
        assertTrue(Sudoku.canPlace(aWorkingSudoku1, 1, 1, 3));

        assertFalse(Sudoku.canPlace(aWorkingSudoku, 0, 0, 0));
        assertFalse(Sudoku.canPlace(aWorkingSudoku, 0, 0, 0));
        assertFalse(Sudoku.canPlace(aWorkingSudoku1, 0, 0, 2));
        assertFalse(Sudoku.canPlace(aWorkingSudoku1, 0, 3, 1));
        assertFalse(Sudoku.canPlace(aWorkingSudoku1, 1, 1, 2));

    }

    @Test
    public void testIsSolved() {

        assertTrue(Backtrack.isSolved(aWorkingSudoku2));

        assertFalse(Backtrack.isSolved(aNotWorkingSudoku1));
        assertFalse(Backtrack.isSolved(aNotWorkingSudoku2));
        assertFalse(Backtrack.isSolved(aNotWorkingSudoku3));
        assertFalse(Backtrack.isSolved(aWorkingSudoku));
        assertFalse(Backtrack.isSolved(aWorkingSudoku1));

    }

    @Test
    public void testBacktrackCount() {

        assertTrue(Backtrack.backtrackCount(aWorkingSudoku2, 2, 3) == 1);
        assertTrue(Backtrack.backtrackCount(n2MainWorkingSudoku, 2, 3) > 1);
        assertTrue(Backtrack.backtrackCount(aWorkingSudoku, 2, 3) > 1);
        assertTrue(Backtrack.backtrackCount(aWorkingSudoku3, 0, 0) > 1);

        assertFalse(Backtrack.backtrackCount(aNotWorkingSudoku1, 0, 0) >= 1);
        assertFalse(Backtrack.backtrackCount(aWorkingSudoku4, 0, 0) > 1);

    }

    @Test
    public void testDLX() {
        int[][] sudoku = new int[][] {
                { 0, 0, 0, 3 },
                { 0, 4, 0, 0 },
                { 0, 1, 0, 0 },
                { 0, 3, 2, 0 },
        };
        int n = (int) Math.sqrt(sudoku.length);
        int nPow6 = (int) Math.pow(n, 6);

        int[][] M = DLX.sudokoToExactCover(sudoku, n);
        assertEquals(nPow6, M.length);
        // If test above passed. M is a binary matrix of size n^6

        Deque<DLX.Node> nodes = DLX.sudokuToDancingLinks(M);
        assertEquals(nPow6 + 1, nodes.size());
        // if test above passes. Nodes is a double ended queue containing Node objects.
        // With the size n^6 + 1 (for the root)

        assertTrue(DLX.search(DLX.findRoot(nodes), new ArrayDeque<DLX.Node>(), true));

        assertEquals(1, DLX.searchCount(DLX.findRoot(nodes), new ArrayDeque<DLX.Node>()));
        // if test above passes. 1 unique solution has been found
    }

}
